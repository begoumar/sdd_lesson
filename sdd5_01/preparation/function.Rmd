---
title: "Faire des fonctions"
output: html_notebook
---

# livre de référence 

- R for Data Science

- R programming

# les grandes étapes

- Pour passer d'instructions vers la fonction : Code -> Extract function
    + nom de la fonction <- function()
- Renommer le variable V par x : Code -> Rename in scope
    + donner des noms explicites aux arguments
- Renvoyer le résultat
- Vérifier le résultat de la fonction

# Comment attribuer à V2 une variable avec les valeurs associées de trismestre

On va partir d'un vecteur de nombre allant de 1:12 ( les mois) et y associer les trismestres. Au sein d'un script R, on va devoir écrire un script avec un titre, un auteur, une license, une date, une version, une section TODO pour la suite des modifications, addresse mail,...

Le point de départ de notre vecteur 

```{r}
(V <- c(1,3,6,4,8,10,8,9))
(V2 <- sample(1:12, replace = TRUE))
```

## première idée : utilisation de boucles et de if 

```{r}
# fonction avec boucles et if
trimester <- function(x) {
  res <- integer(0)
  for(i in 1 : length(x)) {
    if (x[i] < 4) {
    res[i] <- 1
  }else if (x[i] < 7) {
      res[i] <- 2
  }else if (x[i] < 10) {
      res[i] <- 3
  }else res[i] <- 4
  }
  res
}

trimester(x = V)
```

## avec ifelse

```{r}
trimester1 <- function(x){
  ifelse(x <4, 1, 
         ifelse(x < 7,2, 
                ifelse(x < 10, 3, 4)))
}
trimester1(V)
```

## avec %in%

La fonction %in% est vectorisable alors que la fonction if and else ne sont pas vectorisable.

```{r}
# fonction avec %in%
# on prend un vecteur exemple
trimester2 <- function(x){
  if (!is.numeric(x)) 
    stop("x must be a numeric")
  if(any(x < 1  | x > 12))
    # au moins un résultat est vrai : any
    # tous vrai : all
    stop("x must be between 1 and 12")
  
  x2 <- as.integer(x)
  if(any(x !=x2))
    warning("non integer values (rounded down)")
  x <- x2
  
  res <- integer(length(x))
  # détermine si les élements de gauche se trouve dans la liste de droite
  res[x %in% 1:3] <- 1
  res[x %in% 4:6] <- 2
  res[x %in% 7:9] <- 3
  res[x %in% 10:12] <- 4
  res
}
trimester2(V)
```

## Comparaison de trimestre(), trimestr1(), et de trimestre2()

La lisibilité va dépendre de la sensibilité du lecteur, par contre en terme de performance, la seconde solution sera beaucoup plus rapide

### Benchmark
```{r}
# vitesse
grand_vec <- sample(1:12, size = 1000000, replace = TRUE)

#trimester(grand_vec)
#trimester2(grand_vec)
#
bench::mark(trimester(grand_vec), trimester1(grand_vec), trimester2(grand_vec))
```

On peut observer que la fonction trimester2() 3.26 fois plus rapide que trimester(). En terme de mémoire, trimester2() demande 2 fois moins de vitesse. 

### Autres solutions

On ne fait pas de comparaison mais on obtient notre valeur par calcul

```{r}
#(V+2) %/% 3

trimester3 <- function(x){
  (x + 2) %/% 3
}

trimester3(V)

```
ce code est peu lisible mais il est 45 fois plus rapide.

```{r}
bench::mark(trimester(grand_vec), trimester1(grand_vec), trimester2(grand_vec), trimester3(grand_vec))
```

```{r}
trimester4 <- function(x){
  rep(1:4, each = 3)[x]
}

trimester4(V)
```
 
Avec cette nouvelle fonction, la vitesse de calcul de trismestr4 est de 112 fois plus rapide. 

```{r}
bench::mark(trimester(grand_vec), trimester1(grand_vec),
            trimester2(grand_vec), trimester3(grand_vec), trimester4(grand_vec))
```

## Test et programmation défensive

la programmation défénsive a pour but d'arreter le plus vite possible une fonction lors d'une erreur avec un message explicite.

```{r}
trimester2(1:12)

library(testthat)
expect_equal(trimester2(1:12), 
             rep(1:4, each = 3))
expect_error(trimester3("a"))
# accepte seulement des valeurs numériques 
expect_error(trimester2("a"))
expect_error(trimester2(-1))
# nombre non entier accepté avec warning
expect_equal(trimester2(c(1.5,3.9, 4.1)), 
             c(1,1,2))
expect_warning(trimester2(c(1.5,3.9, 4.1)), "non integer values \\(rounded down\\)") # requiert une expression régulière
```

