---
title: "Fonctions : arguments variables et nettoyage en sortie"
output: html_notebook
---

Nous partons d'un exemple de données pour lesquelles nous voulons faire un graphique un peu complexe. Nous voulons créer une fonction personnalisée pour cela.

```{r}
SciViews::R
physico <- read("data/physico.rds")
skimr::skim(physico)
```

Graphique de la salinité en fonction de différentes conditions.

```{r}
omar <- par(mar = c(5.1, 4.1, 1.1, 1.1))
plot(data = physico, S ~ date, type = "n")
lev <- levels(physico$code)
if (length(lev) < 1)
  stop("No levels for 'code'")
cols <- c("black", "red", "blue")
cols <- rep(cols, length.out = length(lev))
# TODO: align length of cols with length of lev
for (i in 1:length(lev)) {
  lines(data = filter(physico, code == lev[i]), S ~ date,
    type = "l", col = cols[i])
}
legend("right", legend = lev, col = cols, lty = 1)
par(omar)
```

Transformation en une fonction personnalisée.

```{r}
plot_by_factor <- function(data, formula, factor, cols, type = "l",
legend.pos = "right", lty = 1L, bty = "o", ...) {
  # Adapt margins
  omar <- par(mar = c(5.1, 4.1, 1.1, 1.1))
  on.exit(par(omar)) # Restore initial margins
  
  # Create the plot area for all curves
  plot(data = data, formula, type = "n", bty = bty, ...)
  
  # Extract levels for factor
  lev <- levels(factor)
  if (length(lev) < 1)
    stop("No levels for 'factor'")
  
  # Make sure we have same number of colors as levels
  cols <- rep(cols, length.out = length(lev))
  
  # Plot each curve
  for (i in 1:length(lev)) {
    lines(data = filter(data, factor == lev[i]), formula,
      type = type, col = cols[i], lty = lty, ...)
  }
  
  # Add a legend
  legend(legend.pos, legend = lev, col = cols, lty = lty, ...)
}

plot_by_factor(physico, S ~ date, physico$code, cols = c("black", "red", "blue"), lwd = 2, bty = "n")
```

Autre usage de ...

```{r}
concat_round <- function(..., .digits = 1L) {
  # Transforme ... into a list
  args <- list(...)
  # Check if the list is empty
  if (length(args) < 1)
    return(character(0))
  
  # Transform rounded numbers into characters for each arg
  for (i in 1:length(args)) {
    if (is.numeric(args[[i]]))
      args[[i]] <- as.character(round(args[[i]], digits = .digits))
  }
  
  # Transformation into a vector
  unlist(args)
}
#concat_round()
concat_round(x = "a", "z", "e", digits = 2.456, .digits = 2L)
```


## Objets S3

```{r}
x <- 1:3
x
class(x)
unclass(x)
```

```{r}
# Ne marche pas
#fct <- factor(x, levels = c("bleu", "vert", "rouge"))
fct <- x
attr(fct, "levels") <- c("bleu", "vert", "rouge")
# levels(fct) <- c("bleu", "vert", "rouge")
attr(fct, "class") <- "factor"
# class(fct) <- "factor"
fct
class(fct)
unclass(fct)
```

Liste et data.frame

```{r}
ll <- list(x = 1:3, y = rnorm(3), z = fct)
ll
```

```{r}
df <- as.data.frame(ll)
df
unclass(df)
```

```{r}
df2 <- ll
class(df2) <- "data.frame"
attr(df2, "row.names") <- 1:3
df2
unclass(df2)
```

Objet avec plusieurs classes

```{r}
ord <- ordered(letters[1:4])
ord
class(ord)
```

Fonctions génériques. Fonctions définies avec le code `UseMethod("...")` à l'intérieur.

```{r}
methods(predict)
methods(class = "factor")
```


## Exercice

Nouvel objet contenant un data.frame et une variable facteur qui fait des sous-groupes.

```{r}
# Constructeur avec new_sdd5() and validate_sdd5()
new_sdd5 <- function(x, series, ...) {
  x <- as.data.frame(x)
  attr(x, "series") <- series
  class(x) <- c("sdd5", "data.frame")
  x
}

validate_sdd5 <- function(x) {
  series <- attr(x, "series")
  if (!is.character(series) && length(series) != 1)
    stop("'series' must be a single character string")
  if (!series %in% names(x))
    stop("'series' must be one variable in 'x'")
  if (!is.factor(x[[series]]))
    stop("'series' must match to a factor column in 'x'")
  x
}

sdd5 <- function(x, series, ...) {
  obj <- new_sdd5(x, series = series, ...)
  validate_sdd5(obj)
}

ps_sdd5 <- sdd5(physico, series = "code")
ps_sdd5

is.sdd5 <- function(x)
  inherits(x, "sdd5")

is.sdd5(physico)
is.sdd5(ps_sdd5)

# as.sdd5() # Pas fait ici
```

Methode `print.sdd5()` spécifique à l'objet.

```{r}
print.sdd5 <- function(x, n = 5, ...) {
  cat("Object 'sdd5' with series defined by", attr(x, "series"), "\n")
  print(head(as.data.frame(x), n = n))
  invisible(x)
}
```

Impression du contenu de ps_sdd5 avec la nouvelle méthode.

```{r}
ps_sdd5
```

Methode `plot.sdd5()`.

```{r}
plot.sdd5 <- function(x, y, formula, cols = NULL, type = "l", legend.pos = "right", lty = 1L, bty = "o", ...) {
  if (!missing(y))
    warning("'y' is not used")
  series <- attr(x, "series")
  fact <- x[[series]]
  if (is.null(cols)) {
    n <- length(levels(fact))
    n <- max(min(n, 3), 8)
    cols <- RColorBrewer::brewer.pal(n, "Dark2")
  }
  plot_by_factor(x, formula = formula, factor = fact, cols = cols, type = type, legend.pos = legend.pos, lty = lty, bty = bty, ...)
}

plot(ps_sdd5, formula = S ~ date)
```

```{r}
plot(ps_sdd5, formula = T ~ number_day)
```

Pour les graphiques ggplot2, le générique s'appelle `autoplot()`.

```{r}
library(ggplot2)

autoplot.sdd5 <- function(object, formula, ...) {
  series <- attr(object, "series")
  env <- parent.frame()
  formula <- deparse(formula) %>.%
    paste(., "%col=%", series) %>.%
    as.formula(., env = env)
  chart(data = physico, S ~ date %col=% code, ...) +
    geom_line()
}

autoplot(ps_sdd5, S ~ date)
```

